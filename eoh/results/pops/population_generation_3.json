[
     {
          "algorithm": "The algorithm selects the next node by minimizing a weighted sum of the distance from the current node to the candidate node and the distance from the candidate node to the destination node, where the weight for the latter is the proportion of nodes already visited.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    total_nodes = distance_matrix.shape[0]\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    best_score = float('inf')\n    next_node = None\n    for candidate in unvisited_nodes:\n        d1 = distance_matrix[current_node, candidate]\n        d2 = distance_matrix[candidate, destination_node]\n        score = d1 + visited_ratio * d2\n        if score < best_score:\n            best_score = score\n            next_node = candidate\n    return next_node",
          "objective": 7.03416,
          "other_inf": null
     },
     {
          "algorithm": "Next node minimizes the product of the distance from current node to candidate and the distance from candidate to destination node divided by their sum, with tie-breaking by immediate distance and then node ID.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_score = float('inf')\n    min_d1 = float('inf')\n    next_node = None\n    \n    for candidate in unvisited_nodes:\n        d1 = distance_matrix[current_node, candidate]\n        d2 = distance_matrix[candidate, destination_node]\n        denom = d1 + d2\n        if denom == 0:\n            score = 0\n        else:\n            score = (d1 * d2) / denom\n            \n        if score < min_score:\n            min_score = score\n            min_d1 = d1\n            next_node = candidate\n        elif score == min_score:\n            if d1 < min_d1:\n                min_d1 = d1\n                next_node = candidate\n            elif d1 == min_d1 and candidate < next_node:\n                next_node = candidate\n                \n    return next_node",
          "objective": 7.45505,
          "other_inf": null
     },
     {
          "algorithm": "\"Next node minimizes (0.6 * distance from current node to candidate + 0.4 * distance from candidate to destination node), with tie-breaking by immediate distance and then node ID.\"",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    alpha = 0.6\n    min_score = float('inf')\n    min_d1 = float('inf')\n    next_node = None\n    \n    for candidate in unvisited_nodes:\n        d1 = distance_matrix[current_node, candidate]\n        d2 = distance_matrix[candidate, destination_node]\n        score = alpha * d1 + (1 - alpha) * d2\n        \n        if score < min_score:\n            min_score = score\n            min_d1 = d1\n            next_node = candidate\n        elif score == min_score:\n            if d1 < min_d1:\n                min_d1 = d1\n                next_node = candidate\n            elif d1 == min_d1 and candidate < next_node:\n                next_node = candidate\n                \n    return next_node",
          "objective": 7.50039,
          "other_inf": null
     },
     {
          "algorithm": " The algorithm selects the next node by minimizing a weighted sum of the distance from the current node to the candidate, the distance from the candidate to the destination, and the average distance from the candidate to all other unvisited nodes, with weights being the visited ratio for the destination distance and the unvisited ratio for the average distance. ",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    total_nodes = distance_matrix.shape[0]\n    visited_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    best_score = float('inf')\n    next_node = None\n    for candidate in unvisited_nodes:\n        d1 = distance_matrix[current_node, candidate]\n        d2 = distance_matrix[candidate, destination_node]\n        other_unvisited = [u for u in unvisited_nodes if u != candidate]\n        if other_unvisited:\n            d3 = np.mean(distance_matrix[candidate, other_unvisited])\n        else:\n            d3 = 0\n        score = d1 + visited_ratio * d2 + (1 - visited_ratio) * d3\n        if score < best_score:\n            best_score = score\n            next_node = candidate\n    return next_node",
          "objective": 7.57794,
          "other_inf": null
     }
]